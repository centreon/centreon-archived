#! /usr/bin/perl -w
################################################################################
# Copyright 2005-2009 MERETHIS
# Centreon is developped by : Julien Mathis and Romain Le Merlus under
# GPL Licence 2.0.
# 
# This program is free software; you can redistribute it and/or modify it under 
# the terms of the GNU General Public License as published by the Free Software 
# Foundation ; either version 2 of the License.
# 
# This program is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A 
# PARTICULAR PURPOSE. See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License along with 
# this program; if not, see <http://www.gnu.org/licenses>.
# 
# Linking this program statically or dynamically with other modules is making a 
# combined work based on this program. Thus, the terms and conditions of the GNU 
# General Public License cover the whole combination.
# 
# As a special exception, the copyright holders of this program give MERETHIS 
# permission to link this program with independent modules to produce an executable, 
# regardless of the license terms of these independent modules, and to copy and 
# distribute the resulting executable under terms of MERETHIS choice, provided that 
# MERETHIS also meet, for each linked independent module, the terms  and conditions 
# of the license of that module. An independent module is a module which is not 
# derived from this program. If you modify this program, you may extend this 
# exception to your version of the program, but you are not obliged to do so. If you
# do not wish to do so, delete this exception statement from your version.
# 
# For more information : contact@centreon.com
# 
# SVN : $URL$
# SVN : $Id$
#
####################################################################################

use strict;

####################################################################
# WHAT DO DO BEFORE LAUNCHING THIS PROGRAM : 
# CREATE THE "log_archive_last_status" TABLE AND ADD 
# UNDETERMINEDTimeScheduled FIELD IN "log_archive_host" AND 
# "log_archive_service"
####################################################################

####################################################################
# Required libs
####################################################################
use DBI;
use POSIX;
use Getopt::Long;
use Time::Local;

####################################################################
# Global Variables
####################################################################

# Include Centreon DB Configuration Variables
use vars qw ($mysql_database_oreon $mysql_database_ods $mysql_host $mysql_user $mysql_passwd);
require "@CENTREON_ETC@/conf.pm";

# Define Var lib dir
my $VarLib = "@CENTREON_VARLIB@";

# archiveDayLog's lock file
my $lock_file = $VarLib."/archiveDayLog.lock";
my $cmdtmp;
my $pid;
if (-e "$lock_file") {
   chomp($pid = `cat $lock_file`);
   my @progTab = split(/\//,$0);
   my $progName = pop(@progTab);
   my $cmd = "ps -p ".$pid." | grep ".$progName;
   $cmdtmp = `$cmd`;
   if (length($cmdtmp) > 0) {
      print("$progName is already running... (pid=$pid)\n");
      exit;
   }
}
$pid = getpgrp(0);
$cmdtmp = `echo $pid > $lock_file`;


# the field "msg_type" in table "log" of Centstorage DB correspond to Nagios Message type 
my %msg_type = ("svc_alerts" 			=> 0,
				"host_alerts" 			=> 1,
				"svc_current_state" 	=> 6,
				"host_current_state"	=> 7,
				"svc_init_state" 		=> 8,
				"host_init_state" 		=> 9);

#Hash tables that will contain host and services availability stats by day
my (%hosts, %services, %host_ids, %service_ids);

# DB Connection instance
my $dbh;
my $dbhoreon;

####################################################################
#FUNCTIONS
####################################################################

#################################
# Program execution help function
#################################
sub print_help {
    print "usage : ".$0." [-r|--rebuild] [-d|--debug] [l|--log <file>]\n";
}

################################################################
# If the given parameters concern an host status information,
# this function is called in function get_hosts_services_stats()
# $start => log fetching begin date
# $row => sql data row
################################################################

sub analyse_host_row($$) {
    my ($start, $row) = (shift, shift);
    if (!defined($hosts{$row->{"host_name"}})) {
    	my $host_id = getHostID($row->{"host_name"}, $dbhoreon);
    	if (defined($host_id) && $host_id) {
    		  if (defined($host_ids{$host_id})) {
    		  	# If host already exist in table log_archive_last_status but host name has changed
    		  	my $entry = $hosts{$host_ids{$host_id}};
			my %new_log_entry;
			while (my ($key, $value) = each (%$entry)) {
			    $new_log_entry{$key} = $value;
			}
			$hosts{$row->{"host_name"}} = \%new_log_entry;
			$host_ids{$host_id} = $row->{"host_name"};
			# renaming services in %services
    		  }else {
    		  	# if it's a new host
				my %log_entry = ("current_state" 		=> "UNDETERMINED",
						 "current_state_time" 	=> $start,
						 "DOWN_D" 				=> 0,
						 "UP_D" 				=> 0,
						 "UNREACHABLE_D" 		=> 0,
						 "UNDETERMINED_D" 		=> 0,
						 "UP_A" 				=> 0,
						 "DOWN_A" 				=> 0,
						 "UNREACHABLE_A" 		=> 0,
						 "host_id"				=> $host_id
						 );
				$hosts{$row->{"host_name"}} = \%log_entry;
    		  }
    		  $host_ids{$host_id} = $row->{"host_name"};
    	}
    }
    if (defined($hosts{$row->{"host_name"}})) {
	    my $log_entry = $hosts{$row->{"host_name"}};
	    if (($row->{"ctime"} >= $log_entry->{"current_state_time"} && $row->{"status"} ne $log_entry->{"current_state"})
		|| (!defined($log_entry->{"current_state_time"}) || ! defined ($log_entry->{"current_state"}))) {
			$log_entry->{$log_entry->{"current_state"}."_D"} += $row->{"ctime"} - $log_entry->{"current_state_time"};
			$log_entry->{"current_state"} = $row->{"status"};
			$log_entry->{"current_state_time"} = $row->{"ctime"};
			if ($row->{"msg_type"} == $msg_type{"host_alerts"}) {
			    $log_entry->{$row->{"status"}."_A"}++;
			}
			$hosts{$row->{"host_name"}} = $log_entry;
	    }
    }
}

################################################################
# If the given parameters concern a service status information,
# this function is called in function get_hosts_services_stats()
# $start => log fetching begin date
# $row => sql data row
################################################################
sub analyse_service_row($$) {
    my ($start, $row) = (shift, shift);

    $row->{"service_description"} =~ s/\//#S#/g;
    $row->{"service_description"} =~ s/\\/#BS#/g;

    my $svc = $row->{"host_name"}.";".$row->{"service_description"};
    if (!defined($services{$svc})) {
    	# getting host id and service id
    	my $host_id = getHostID($row->{"host_name"}, $dbhoreon);
    	my $service_id;
    	if (defined($host_id) && $host_id) { 
	    $service_id = getServiceIDByName($row->{"host_name"}, $row->{"service_description"}, $dbhoreon);
    	}
    	if (defined($service_id) && $service_id && defined($host_id) && $host_id) {
	    if (defined($service_ids{$host_id.";".$service_id})) {
		# If service already exist in table log_archive_last_status but service description has changed
		my $entry = $services{$service_ids{$host_id.";".$service_id}};
		my %new_log_entry;
		while (my ($key, $value) = each (%$entry)) {
		    $new_log_entry{$key} = $value;
		} 
		$services{$svc} = \%new_log_entry;
		$service_ids{$host_id.";".$service_id} = $svc;
	    }else {
		# if it's a new service
		my %log_entry = ("current_state" 		=> "UNDETERMINED",
				 "current_state_time" 	=> $start,
				 "CRITICAL_D" 			=> 0,
				 "WARNING_D" 			=> 0,
				 "UNKNOWN_D" 			=> 0,
				 "OK_D"					=> 0,
				 "UNDETERMINED_D" 		=> 0,
				 "CRITICAL_A" 			=> 0,
				 "WARNING_A" 			=> 0,
				 "UNKNOWN_A" 			=> 0,
				 "OK_A"					=> 0,
				 "host_id"				=> $host_id,
				 "service_id"			=> $service_id
				 );
		$services{$svc} = \%log_entry;
	    }
	    $service_ids{$host_id.";".$service_id} = $svc;
    	}
    }
    if (defined($services{$svc})) {
	my $log_entry = $services{$svc};
	if ($row->{"ctime"} >= $log_entry->{"current_state_time"} && $row->{"status"} ne $log_entry->{"current_state"}) {
	    $log_entry->{$log_entry->{"current_state"}."_D"} += $row->{"ctime"} - $log_entry->{"current_state_time"};
	    $log_entry->{"current_state"} = $row->{"status"};
	    $log_entry->{"current_state_time"} = $row->{"ctime"};
	    if ($row->{"msg_type"} == $msg_type{"svc_alerts"}) {
		$log_entry->{$row->{"status"}."_A"}++;
	    }
	    $services{$svc} = $log_entry;
	}
    }
}

##################################################################################
# This function gets stats on hosts and services availability for the given period
##################################################################################
sub get_hosts_services_stats ($$) { 
    my ($start, $end) = (shift, shift);
    my $query = " SELECT * FROM `log` ".
				" WHERE `msg_type` IN ('".$msg_type{"host_alerts"}."','".$msg_type{"host_current_state"}."','".
										$msg_type{"host_init_state"}."', '".$msg_type{"svc_alerts"}."','".
										$msg_type{"svc_current_state"}."','".$msg_type{"svc_init_state"}."') ".
				" AND `ctime` >= ".$start." AND `ctime` <= ".$end.
				" AND (`type` = 'HARD' OR (`type` = 'SOFT' AND `status` = 'OK'))".
				" ORDER BY `ctime`";
    my $sth = $dbh->prepare($query);
    die "Error : " . $dbh->errstr . "\n" if (!$sth);
    $sth->execute();
    die "Error : " . $dbh->errstr . "\n" if (!$sth);
    while (my $row = $sth->fetchrow_hashref()) {
    	$row->{'host_name'} = uc($row->{'host_name'});
		if ($row->{"msg_type"} == $msg_type{"host_alerts"} 
		    || $row->{"msg_type"} == $msg_type{"host_current_state"} 
		    || $row->{"msg_type"} == $msg_type{"host_init_state"}) {
		    analyse_host_row($start, $row);
		} elsif ($row->{"msg_type"} == $msg_type{"svc_alerts"} 
			 || $row->{"msg_type"} == $msg_type{"svc_current_state"} 
			 || $row->{"msg_type"} == $msg_type{"svc_init_state"}){
			 $row->{'service_description'} = uc($row->{'service_description'});
		   	 analyse_service_row($start, $row);
		}
    }
    $sth->finish();
}

########################################################################
# This function gets last host and services status
# in the time ignored in the time period
# example : if the time period is 09h00-19h00 and $start_time is 09h00
# the function gets the last status between 19h00 and $start_time (9h00)
########################################################################
sub get_last_status_in_ignored_time($$) {
    my ($start_time, $last_day_end) = (shift, shift);
    my $query = " SELECT * FROM `log` ".
				" WHERE `ctime` >= ".$last_day_end." AND `ctime` <= ".$start_time." ".
				" AND `msg_type` IN ('".$msg_type{"host_alerts"}."', '".$msg_type{"svc_alerts"}."', '".
									$msg_type{"host_current_state"}."', '".$msg_type{"svc_current_state"}.
									"', '".$msg_type{"host_init_state"}."', '".$msg_type{"svc_current_state"}."') ".
				" AND (`type` = 'HARD' OR (`type` = 'SOFT' AND `status` = 'OK'))".
				" ORDER BY `ctime`";	
    my $sth = $dbh->prepare($query);
    die "Error: " . $dbh->errstr . "\n" if (!$sth);
    $sth->execute;
    die "Error: " . $dbh->errstr . "\n" if (!$sth);
    while (my $row = $sth->fetchrow_hashref()) {

	$row->{"host_name"} =~ s/\//#S#/g;
	$row->{"host_name"} =~ s/\\/#BS#/g;
	$row->{"host_name"} = uc($row->{"host_name"});

	if (!defined($row->{"service_description"})) {
	    if (defined($hosts{$row->{"host_name"}})) {
		my $entry = $hosts{$row->{"host_name"}};
		$entry->{"current_state"} = $row->{"status"};
		$entry->{"current_state_time"} = $row->{"ctime"};
		$hosts{$row->{"host_name"}} = $entry;
	    } else {
		my $host_id = getHostID($row->{"host_name"}, $dbhoreon);
		if (defined($host_id) && $host_id) {
		    if (defined($host_ids{$host_id})) {
			# If host already exist in table log_archive_last_status but host name has changed
			my $entry = $hosts{$host_ids{$host_id}};
			$entry->{"current_state"} = $row->{"status"};
			$entry->{"current_state_time"} = $row->{"ctime"};
                        my %new_log_entry;
                        while (my ($key, $value) = each (%$entry)) {
                            $new_log_entry{$key} = $value;
                        }
                        $hosts{$row->{"host_name"}} = \%new_log_entry;
                        $host_ids{$host_id} = $row->{"host_name"};

		    }else {
			# if it's a new host
			my %log_entry = ("current_state" 	=> $row->{"status"},
					 "current_state_time"	=> $row->{"ctime"},
					 "DOWN_D" 				=> 0,
					 "UP_D" 				=> 0,
					 "UNREACHABLE_D" 		=> 0,
					 "UNDETERMINED_D" 		=> 0,
					 "UP_A" 				=> 0,
					 "DOWN_A" 				=> 0,
					 "UNREACHABLE_A" 		=> 0,
					 "host_id"				=> $host_id);
			$hosts{$row->{"host_name"}} = \%log_entry;
		    }
		    $host_ids{$host_id} = $row->{"host_name"};
		}
	    }
	}else {
	    $row->{"service_description"} =~ s/\//#S#/g;
	    $row->{"service_description"} =~ s/\\/#BS#/g;
	    $row->{"service_description"} = uc($row->{"service_description"});
	    # service already exists in table log_archive_last_status
	    if (defined($services{$row->{"host_name"}.";".$row->{"service_description"}})) {
		my $entry = $services{$row->{"host_name"}.";".$row->{"service_description"}};
		$entry->{"current_state"} = $row->{"status"};
		$entry->{"current_state_time"} = $row->{"ctime"};
		$services{$row->{"host_name"}.";".$row->{"service_description"}} = $entry;
	    } else {
		# getting host id and service id
		my $host_id = getHostID($row->{"host_name"}, $dbhoreon);
		my $service_id;
		if (defined($host_id) && $host_id) { 
		    $service_id = getServiceID($host_id, $row->{"service_description"}, $dbhoreon);
		}
		if (defined($service_id) && $service_id && defined($host_id) && $host_id) {
		    if (defined($service_ids{$host_id.";".$service_id})) {
			# If service already exist in table log_archive_last_status but service description has changed
			my $entry = $services{$service_ids{$host_id.";".$service_id}};
			$entry->{"current_state"} = $row->{"status"};
			$entry->{"current_state_time"} = $row->{"ctime"};
			my %new_log_entry;
			while (my ($key, $value) = each (%$entry)) {
			    $new_log_entry{$key} = $value;
			}
			$services{$row->{"host_name"}.";".$row->{"service_description"}} = \%new_log_entry;
			$service_ids{$host_id.";".$service_id} = $row->{"host_name"}.";".$row->{"service_description"};
		    }else {
			# if it's a new service
			my %log_entry = ("current_state" 	=> $row->{"status"},
					 "current_state_time"	=> $row->{"ctime"},
					 "CRITICAL_D" 			=> 0,
					 "WARNING_D" 			=> 0,
					 "UNKNOWN_D" 			=> 0,
					 "OK_D"					=> 0,
					 "UNDETERMINED_D" 		=> 0,
					 "CRITICAL_A" 			=> 0,
					 "WARNING_A" 			=> 0,
					 "UNKNOWN_A" 			=> 0,
					 "OK_A"					=> 0,
					 "host_id"				=> $host_id,
					 "service_id"			=> $service_id
					 );
			$services{$row->{"host_name"}.";".$row->{"service_description"}} = \%log_entry;
			$service_ids{$host_id.";".$service_id} = $row->{"host_name"}.";".$row->{"service_description"};
		    }
		}
	    }
	}
    }
    $sth->finish();
}

###################################################################
# This function gets last hosts and services status
# that were stored in the table `last_status_log` of centstorage DB
###################################################################
sub get_last_status ($$) {
    my ($start_time, $last_day_end) = (shift, shift);
    my $sth = $dbh->prepare(" SELECT * FROM `log_archive_last_status`");
    die "Error: " . $dbh->errstr . "\n" if (!$sth);
    $sth->execute();
    die "Error: " . $dbh->errstr . "\n" if (!$sth);
    while (my $row = $sth->fetchrow_hashref()) {
    	
		if (!defined($row->{"service_description"})) {
		    my %log_entry = ("current_state" 		=> $row->{"status"},
				     "current_state_time"	=> $row->{"ctime"},
				     "DOWN_D" 				=> 0,
				     "UP_D" 				=> 0,
				     "UNREACHABLE_D" 		=> 0,
				     "UNDETERMINED_D" 		=> 0,
				     "UP_A" 				=> 0,
				     "DOWN_A" 				=> 0,
				     "UNREACHABLE_A" 		=> 0,
				     "host_id"				=> $row->{"host_id"}
				     );
		    $hosts{$row->{"host_name"}} = \%log_entry;
			$host_ids{$row->{"host_id"}} = $row->{"host_name"};
		}else {
		    my %log_entry = ("current_state" 		=> $row->{"status"},
				     "current_state_time"	=> $row->{"ctime"},
				     "CRITICAL_D" 			=> 0,
				     "WARNING_D" 			=> 0,
				     "UNKNOWN_D" 			=> 0,
				     "OK_D"					=> 0,
				     "UNDETERMINED_D" 		=> 0,
				     "CRITICAL_A" 			=> 0,
				     "WARNING_A" 			=> 0,
				     "UNKNOWN_A" 			=> 0,
				     "OK_A"					=> 0,
				     "host_id"				=> $row->{"host_id"},
				     "service_id"			=> $row->{"service_id"}
				     );
		    $services{$row->{"host_name"}.";".$row->{"service_description"}} = \%log_entry;
		    $service_ids{$row->{"host_id"}.";".$row->{"service_id"}} = $row->{"host_name"}.";".$row->{"service_description"};
		} 
    }
    $sth->finish();
    get_last_status_in_ignored_time($start_time, $last_day_end);
    while (my ($key, $value) = each (%services)) {
		if ($value->{"current_state_time"} < $start_time) {
		    $value->{"current_state_time"} = $start_time;
		    $services{$key} = $value;
		}
    }
    while (my ($key, $value) = each (%hosts)) {
	if ($value->{"current_state_time"} < $start_time) {
	    $value->{"current_state_time"} = $start_time;
	    $hosts{$key} = $value;
	}
    }
}

#################
# Debug functions
#################
sub display_host_stats {
    while (my ($key, $value) = each (%hosts)) {
	my $log_entry = $value;
	print $key." : ".$log_entry->{"current_state"}.", ".$log_entry->{"current_state_time"}.", ".$log_entry->{"UP_D"}."-".$log_entry->{"UP_A"}."-".$log_entry->{"DOWN_D"}."-".
	    $log_entry->{"DOWN_A"}."-".$log_entry->{"UNREACHABLE_D"}."-".$log_entry->{"UNREACHABLE_A"}."-".$log_entry->{"UNDETERMINED_D"}."\n";
    }
}

sub display_services_stats {
    while (my ($key, $value) = each (%services)) {
	my $log_entry = $value;
	print $key." : ".$log_entry->{"current_state"}.", ".$log_entry->{"current_state_time"}.", ".$log_entry->{"OK_D"}."-".$log_entry->{"OK_A"}."-".$log_entry->{"CRITICAL_D"}."-".
	    $log_entry->{"CRITICAL_A"}."-".$log_entry->{"WARNING_D"}."-".$log_entry->{"WARNING_A"}."-".$log_entry->{"UNKNOWN_D"}."-".$log_entry->{"UNKNOWN_A"}.
	    "-".$log_entry->{"UNDETERMINED_D"}."\n";
    }
}

sub getServiceID($$$){
    $_[1] =~ s/\&/\&amp\;/g;
    
    my $con = $_[2];								
    my $sth2 = $con->prepare("SELECT `service_id` FROM `service`, `host_service_relation` hsr ".
							"WHERE hsr.`host_host_id` = '".$_[0]."' AND hsr.`service_service_id` = `service_id` ".
							"AND UPPER(`service_description`) = '".$_[1]."' AND `service_register` = '1' LIMIT 1");
    if (!$sth2->execute) {
		print("Error when getting service id : " . $sth2->errstr . "\n");
    }
    my $data = $sth2->fetchrow_hashref();
    $sth2->finish();
    if (!defined($data->{'service_id'}) && !$data->{'service_id'}){
		$sth2 = $con->prepare("SELECT `service_id` FROM `hostgroup_relation` hgr, `service`, `host_service_relation` hsr" .
							" WHERE hgr.`host_host_id` = '".$_[0]."' AND hsr.`hostgroup_hg_id` = hgr.`hostgroup_hg_id`" .
							" AND `service_id` = hsr.`service_service_id` AND UPPER(`service_description`) = '".$_[1]."' AND `service_register` = '1'");
		if (!$sth2->execute) {
			print("Error when getting service id 2 : " . $sth2->errstr . "\n");
		}
		my $data2 = $sth2->fetchrow_hashref();
		my $service_id = $data2->{'service_id'};
		undef($data);
		undef($data2);
		undef($sth2);
		if (defined($service_id)){
		    return $service_id;
		} else {
		    return 0;
		}
    } else {
		my $service_id = $data->{'service_id'};
		undef($data);
		return $service_id;
    }
}
sub getServiceIDByName($$$){
    $_[1] =~ s/\&/\&amp\;/g;
    
    my $con = $_[2];								
    my $sth2 = $con->prepare("SELECT `service_id` FROM `service`, `host_service_relation` hsr, `host` h ".
							"WHERE hsr.`host_host_id` = h.`host_id` and UPPER(h.`host_name`)='".$_[0]."' AND hsr.`service_service_id` = `service_id` ".
							"AND UPPER(`service_description`) = '".$_[1]."' AND `service_register` = '1' LIMIT 1");
    if (!$sth2->execute) {
		print("Error when getting service id : " . $sth2->errstr . "\n");
    }
    my $data = $sth2->fetchrow_hashref();
    $sth2->finish();
    if (!defined($data->{'service_id'}) && !$data->{'service_id'}){
		$sth2 = $con->prepare("SELECT `service_id` FROM `hostgroup_relation` hgr, `service`, `host_service_relation` hsr, `host` h" .
							" WHERE hgr.`host_host_id` = h.`host_id` and UPPER(h.`host_name`)='".$_[0]."' AND hsr.`hostgroup_hg_id` = hgr.`hostgroup_hg_id`" .
							" AND `service_id` = hsr.`service_service_id` AND UPPER(`service_description`) = '".$_[1]."' AND `service_register` = '1'");
		if (!$sth2->execute) {
			print("Error when getting service id 2 : " . $sth2->errstr . "\n");
		}
		my $data2 = $sth2->fetchrow_hashref();
		my $service_id = $data2->{'service_id'};
		undef($data);
		undef($data2);
		undef($sth2);
		if (defined($service_id)){
		    return $service_id;
		} else {
		    return 0;
		}
    } else {
		my $service_id = $data->{'service_id'};
		undef($data);
		return $service_id;
    }
}

sub getHostID($$){	
    my $con = $_[1];
    my $sth2 = $con->prepare("SELECT `host_id` FROM `host` WHERE UPPER(`host_name`) = '".$_[0]."' AND `host_register` = '1'");
    print("Error:" . $sth2->errstr . "\n") if (!$sth2->execute);
    my $data_host = $sth2->fetchrow_hashref();
    my $host_id = $data_host->{'host_id'};
    $sth2->finish();
    undef($data_host);
    return $host_id;
}
##########################################################################
# Insertion of hosts stats in ""log_archive_host"" table of centstorage DB
##########################################################################

sub insert_hosts_stats_in_db ($$) {
    my ($date_start, $date_end) = (shift, shift); 

    # beginning of query that will insert host stats
    my $archive_insert_query = "INSERT INTO `log_archive_host` (`host_id`, `UPTimeScheduled`, `UPnbEvent`, `DOWNTimeScheduled`, `DOWNnbEvent`, ".
	"`UNREACHABLETimeScheduled`, `UNREACHABLEnbEvent`, `UNDETERMINEDTimeScheduled`, `date_start`, `date_end`) VALUES ";

    # beginning of query that will insert host day last status
    my $status_insert_query = " INSERT INTO `log_archive_last_status` (`host_name`, `host_id`, `status`, `ctime`) VALUES ";

    # beginning of query that will delete host previous day last status
    my $status_delete_query = "DELETE FROM `log_archive_last_status` WHERE `service_description` is null AND `host_name`=";

    while (my ($key, $value) = each (%hosts)) {
	# Adding last state duration
	$value->{$value->{"current_state"}."_D"} += $date_end - $value->{"current_state_time"};

	# Replace special chars
	$key =~ s/\//#S#/g;
	$key =~ s/\\/#BS#/g;

	# Fetching host_id from host_name if host_id is not defined in %value hash table
	my $host_id;
	if (!defined($value->{'host_id'}) && !$value->{'host_id'}) {
	    my $host_id = getHostID($key, $dbhoreon);
	}else {
	    $host_id = $value->{'host_id'};
	}
	if (defined($host_id) && $host_id) {
	    # Deleting last status for host in table
	    $dbh->do($status_delete_query."'".$key."'");
	    if (getHostID($key, $dbhoreon)) {
		# Inserting new stats for host in table
		my $archive_insert_suffix = "('".$host_id."', '".$value->{"UP_D"}."', '".$value->{"UP_A"}."', '".$value->{"DOWN_D"}."', '".$value->{"DOWN_A"}."', ".
		    "'".$value->{"UNREACHABLE_D"}."', '".$value->{"UNREACHABLE_A"}."', '".$value->{"UNDETERMINED_D"}."', '".$date_start."', '".$date_end."')";
		$dbh->do($archive_insert_query.$archive_insert_suffix);

		# inserting latest known status for host in table
		my $status_insert_suffix = "('".$key."', '".$host_id."', '".$value->{"current_state"}."', '".$date_end."')";
		$dbh->do($status_insert_query.$status_insert_suffix);
	    }
	}
    }
}


################################################################################
# Insertion of services stats in ""log_archive_service"" table of centstorage DB
################################################################################


sub insert_services_stats_in_db ($$) {

    my ($date_start, $date_end) = (shift, shift);

    # Query beginning for service stats insert query
    my $archive_insert_query = "INSERT INTO `log_archive_service` (`host_id`, `service_id`, `OKTimeScheduled`, `OKnbEvent`, `WARNINGTimeScheduled`, `WARNINGnbEvent`, ".
	" `CRITICALTimeScheduled`, `CRITICALnbEvent`, `UNKNOWNTimeScheduled`, `UNKNOWNnbEvent`, ".
	" `UNDETERMINEDTimeScheduled`, `date_start`, `date_end`)  VALUES ";
    # Query beginning for service last known status delete query
    my $status_delete_query = "DELETE FROM `log_archive_last_status` WHERE ";
    # Query beginning for service last known status insert query
    my $status_insert_query = " INSERT INTO `log_archive_last_status` (`host_name`, `host_id`, `service_description`, `service_id`, `status`, `ctime`) VALUES "; 

    while (my ($key, $value) = each (%services)) {

	# Adding last state duration
	$value->{$value->{"current_state"}."_D"} += $date_end - $value->{"current_state_time"};

	# Fetching host_id from host_name for insertion in log_archive_service table
	my ($host_name, $svc_desc) = split (";", $key);

	# Replace special chars
	$host_name =~ s/\//#S#/g;
	$host_name =~ s/\\/#BS#/g;
	$svc_desc =~ s/\//#S#/g;
	$svc_desc =~ s/\\/#BS#/g;

	# Fetching host_id from host_name if host_id is not defined in %value hash table
	my $host_id;
	if (!defined($value->{'host_id'}) && !$value->{'host_id'}) {
	    my $host_id = getHostID($key, $dbhoreon);
	}else {
	    $host_id = $value->{'host_id'};
	}
	if (defined($host_id) && $host_id) {
	    my $svc_id;
	    if (!defined($value->{'service_id'}) && !$value->{'service_id'}) {
		$svc_id = getServiceID($host_id, $svc_desc, $dbhoreon);
	    }else {
		$svc_id = $value->{'service_id'};
	    }
	    if (defined($svc_id) && $svc_id) {
		# Deleting last status for service in table
		my  $status_delete_suffix = "host_name = '".$host_name."' AND service_description = '".$svc_desc."'";
		$dbh->do($status_delete_query.$status_delete_suffix);
		
		if (getServiceIDByName($host_name, $svc_desc, $dbhoreon)) {
		    # inserting new entry in log_archive_service table
		    my $archive_insert_suffix = "('".$host_id."', '".$svc_id."', '".$value->{"OK_D"}."', '".$value->{"OK_A"}."', '".$value->{"WARNING_D"}."', '".$value->{"WARNING_A"}."', ".
			"'".$value->{"CRITICAL_D"}."', '".$value->{"CRITICAL_A"}."', '".$value->{"UNKNOWN_D"}."', '".$value->{"UNKNOWN_A"}."', ".
			"'".$value->{"UNDETERMINED_D"}."', '".$date_start."', '".$date_end."')";
		    $dbh->do($archive_insert_query.$archive_insert_suffix);
		    # inserting latest known status for host in table 
		    my $status_insert_suffix = "('".$host_name."', '".$host_id."', '".$svc_desc."', '".$svc_id."', '".$value->{"current_state"}."', '".$date_end."')";
		    $dbh->do($status_insert_query.$status_insert_suffix);
		}
	    }
	}
    }
}

#####################################################
# function to call to archive last past day log
# when the program is called by a cron or a scheduler
#####################################################

sub archive_day_log ($$) {
	# Getting last day start and end timestamps
	my ($start_time, $end_time) = (shift, shift);

	# Getting last day end in $last_day_end
	my $last_day_end = $start_time - ((60 * 60 * 24) - ($end_time - $start_time));

	get_last_status($start_time, $last_day_end);
	get_hosts_services_stats($start_time, $end_time);
	insert_hosts_stats_in_db($start_time, $end_time);
	insert_services_stats_in_db($start_time, $end_time);
}

#####################################################
# function that checks if the log is already built
#####################################################

sub check_date($$$) {
	my ($day, $month, $year) = (shift, shift, shift);
	my $tmp_file = $VarLib . "/archiveDayLog.last";
	my $last;
	my $now;
	my $write_cmd;
	
	$now = $day.$month.$year;
	if (-e "$tmp_file") {
    	chomp($last = `cat $tmp_file`);
    	$write_cmd = `echo $now > $tmp_file`;
   		if ($now == $last) {
   			return 0;
   		}
   		else {
   			return 1;
   		}
	}
	$write_cmd = `echo $now > $tmp_file`;
	return 1;
}

############################################################################################################
# Main function parse parameters 
# and select to build archive for one day log or to rebuild all archives
# The table contact_param from Centreon DB contains infos that allows to filter days of week and time period
# to archive stats between two given hours and specific days of week    
#############################################################################################################

sub main {
	
    #Getting options
    my %options;
    Getopt::Long::Configure('bundling');
    GetOptions ("h|help" 	=> \$options{"help"},
		"d|debug" 	=> \$options{"debug"},
		"r|rebuild" => \$options{"rebuild"},
		"l|log"		=> \$options{"log"});
    
    if ($options{"help"}) {
		print_help;
    }
    
    # Initializing MySQL DB connection
    $dbh = DBI->connect("DBI:mysql:database=".$mysql_database_ods.";host=".$mysql_host, $mysql_user, $mysql_passwd,
			{'RaiseError' => 0, 'PrintError' => 0, 'AutoCommit' => 1});
    $dbhoreon = DBI->connect("DBI:mysql:database=".$mysql_database_oreon.";host=".$mysql_host, $mysql_user, $mysql_passwd,
			     {'RaiseError' => 0, 'PrintError' => 0, 'AutoCommit' => 1});
    
    # Getting time_period in which we must collect logs
    my $sth = $dbhoreon->prepare("SELECT * FROM `contact_param` WHERE `cp_contact_id` is null");
    $sth->execute;
    if (!$sth) {
		print "error";
    }

    my %time_period;
    while (my $row = $sth->fetchrow_hashref()) {
		$time_period{$row->{"cp_key"}} = $row->{"cp_value"};
    }
    $sth->finish;
        
    # initialising each day time_period to 24 hours
    $time_period{"day_start_time"} = 0;
    $time_period{"day_end_time"} = 60 * 60 * 24;
    
    #initialising time_period by getting infos from Centreon DB
    if (defined($time_period{"report_minute_start"}) && defined($time_period{"report_hour_start"})) {
		$time_period{"day_start_time"} = mktime(0, $time_period{"report_minute_start"}, $time_period{"report_hour_start"}, 0, 0, 100,0,0,-1)
		    							- mktime(0, 0, 0, 0, 0, 100,0,0,-1);
    }
    if (defined($time_period{"report_minute_end"}) && defined($time_period{"report_hour_end"})) {
		$time_period{"day_end_time"} = mktime(0, $time_period{"report_minute_end"}, $time_period{"report_hour_end"}, 0, 0, 100,0,0,-1)
		    							- mktime(0, 0, 0, 0, 0, 100,0,0,-1);
    }
    
    if ($options{"rebuild"}) {
		# rebuiling all archives from log table
		rebuild_archives(\%time_period);
    } else {
		# building archive for last past dat		
		my ($day,$month,$year) = (localtime(time))[3,4,5];
		if (check_date($day, $month, $year)) {			
			my $yesterday_real_start =  mktime(0,0,0,$day,$month,$year,0,0,-1) - (60 * 60 * 24);
			archive_day_log($yesterday_real_start + $time_period{"day_start_time"}, $yesterday_real_start + $time_period{"day_end_time"});
		}		
    }
    if ($options{"debug"}) {
		display_services_stats;
		display_host_stats;
    }
    $dbh->disconnect();
    $dbhoreon->disconnect();
}

sub rebuild_archives($) {
    my $time_period = shift;
    my $one_day_real_duration = 60 * 60 * 24;
    
    # Emptying log archives tables 
    $dbh->do("TRUNCATE TABLE `log_archive_host`");
    $dbh->do("TRUNCATE TABLE `log_archive_service`");
    $dbh->do("TRUNCATE TABLE `log_archive_last_status`");
    
    # Getting first log and last log times
    my $query = "SELECT min(`ctime`) as minc, max(`ctime`) as maxc FROM `log`";
    my $sth = $dbh->prepare($query);
    $sth->execute;
    my ($start, $end) = (0,0);
    if (my $row = $sth->fetchrow_hashref()) {
		($start, $end) = ($row->{"minc"}, $row->{"maxc"});
    }
    my ($day,$month,$year) = (localtime(time))[3,4,5];
    my $today_begin =  mktime(0,0,0,$day,$month,$year,0,0,-1);
    #my $today_begin = $now - ($now % $one_day_real_duration);
    if ($end > $today_begin) {
		$end = $today_begin;
    }
    $sth->finish;
    
    # Getting list of days between the first log and last log
    my @days;
    ($day,$month,$year) = (localtime($start))[3,4,5];
    $start =  mktime(0,0,0,$day,$month,$year,0,0,-1);
    my $previous_day = mktime(0,0,0,$day - 1,$month,$year,0,0,-1);
    while ($start < $end) {
		# getting day beginning => 00h 00min
		# if there is few hour gap (time change : winter/summer), we also readjust it
		($day,$month,$year) = (localtime($start))[3,4,5];
		$start = mktime(0,0,0,$day,$month,$year,0,0,-1);
		if ($start == $previous_day) {
		    $start = mktime(0,0,0,$day + 1,$month,$year,0,0,-1);
		}
		# setting day beginning/end hour and minute with the value set in centreon DB
		my $day_start = $start +  $time_period->{"day_start_time"};
		my $day_end = $start +  $time_period->{"day_end_time"};
		my %period = ("day_start" => $day_start, "day_end" => $day_end);
		# adding new day delimited by $day_start and $day_end in days list table
		push @days, \%period;
		 
		$previous_day = $start;
#		$start += $one_day_real_duration;
		$day++;
		$start = mktime(0,0,0,$day,$month,$year,0,0,-1);
    }
    my @days_in_order;
    for (my $i = 0 ; $i <  scalar(@days); $i++) {
		if (defined($days[$i])) {	
		    push @days_in_order, $days[$i];
		}
    }
    # archiving logs for each days
    foreach(@days_in_order) {
    	# print $_->{"day_start"}." ".$_->{"day_end"}."\n";
	print "rebuilding : ".(localtime($_->{"day_start"}))[4]."/".(localtime($_->{"day_start"}))[3]."/".(1900+(localtime($_->{"day_start"}))[5])." ".(localtime($_->{"day_start"}))[2].":".(localtime($_->{"day_start"}))[1];
	print " To ".(localtime($_->{"day_end"}))[4]."/".(localtime($_->{"day_end"}))[3]."/".(1900+(localtime($_->{"day_end"}))[5])." ".(localtime($_->{"day_end"}))[2].":".(localtime($_->{"day_end"}))[1]."\n";
	archive_day_log($_->{"day_start"}, $_->{"day_end"});
	undef(%hosts);
	undef(%services);
	undef(%host_ids);
	undef(%service_ids);
    }
}

#####################################################
# MAIN EXECUTION 
#####################################################
main();

my $cmd = `rm -rf $lock_file`;
