/* Tooltipster v3.3.0 */ (function (e, t, n) {
  function s(t, n) {
    this.bodyOverflowX;
    this.callbacks = { hide: [], show: [] };
    this.checkInterval = null;
    this.Content;
    this.$el = e(t);
    this.$elProxy;
    this.elProxyPosition;
    this.enabled = true;
    this.options = e.extend({}, i, n);
    this.mouseIsOverProxy = false;
    this.namespace = `tooltipster-${Math.round(Math.random() * 1e5)}`;
    this.Status = 'hidden';
    this.timerHide = null;
    this.timerShow = null;
    this.$tooltip;
    this.options.iconTheme = this.options.iconTheme.replace('.', '');
    this.options.theme = this.options.theme.replace('.', '');
    this._init();
  }
  const o = (t, n) => {
    let r = true;
    e.each(t, (e, i) => {
      if (typeof n[e] === 'undefined' || t[e] !== n[e]) {
        r = false;
        return false;
      }
    });
    return r;
  };
  const f = () => !a && u;
  const l = () => {
    const e = n.body || n.documentElement;
    const t = e.style;
    let r = 'transition';
    if (typeof t[r] === 'string') {
      return true;
    }
    (v = ['Moz', 'Webkit', 'Khtml', 'O', 'ms']),
      (r = r.charAt(0).toUpperCase() + r.substr(1));
    for (let i = 0; i < v.length; i++) {
      if (typeof t[v[i] + r] === 'string') {
        return true;
      }
    }
    return false;
  };
  const r = 'tooltipster';
  var i = {
    animation: 'alpha',
    arrow: true,
    arrowColor: '',
    autoClose: true,
    content: null,
    contentAsHTML: false,
    contentCloning: true,
    debug: true,
    delay: 200,
    functionAfter: (e) => {},
    functionBefore: (e, t) => {
      t();
    },
    functionInit: (e, t) => {},
    functionReady: (e, t) => {},
    hideOnClick: false,
    icon: '(?)',
    maxWidth: null,
    iconCloning: true,
    minWidth: 0,
    iconDesktop: false,
    iconTheme: 'tooltipster-icon',
    iconTouch: false,
    interactive: false,
    interactiveTolerance: 350,
    multiple: false,
    offsetX: 0,
    offsetY: 0,
    onlyOne: false,
    position: 'top',
    positionTracker: false,
    positionTrackerCallback(e) {
      if (this.option('trigger') == 'hover' && this.option('autoClose')) {
        this.hide();
      }
    },
    restoration: 'current',
    speed: 350,
    theme: 'tooltipster-default',
    timer: 0,
    touchDevices: true,
    trigger: 'hover',
    updateAnimation: true,
  };
  s.prototype = {
    _content_insert() {
      const e = this;
      var t = this.$tooltip.find('.tooltipster-content');
      if (typeof e.Content === 'string' && !e.options.contentAsHTML) {
        t.text(e.Content);
      } else {
        t.empty().append(e.Content);
      }
    },
    _content_set(e) {
      if (typeof e === 'object' && e !== null && this.options.contentCloning) {
        e = e.clone(true);
      }
      this.Content = e;
    },
    _init() {
      const t = this;
      if (n.querySelector) {
        let r = null;
        if (t.$el.data('tooltipster-initialTitle') === undefined) {
          r = t.$el.attr('title');
          if (r === undefined) r = null;
          t.$el.data('tooltipster-initialTitle', r);
        }
        if (t.options.content !== null) {
          t._content_set(t.options.content);
        } else {
          t._content_set(r);
        }
        const i = t.options.functionInit.call(t.$el, t.$el, t.Content);
        if (typeof i !== 'undefined') t._content_set(i);
        t.$el.removeAttr('title').addClass('tooltipstered');
        if ((!u && t.options.iconDesktop) || (u && t.options.iconTouch)) {
          if (typeof t.options.icon === 'string') {
            t.$elProxy = e(`<span class="${t.options.iconTheme}"></span>`);
            t.$elProxy.text(t.options.icon);
          } else if (t.options.iconCloning)
            t.$elProxy = t.options.icon.clone(true);
          else t.$elProxy = t.options.icon;
          t.$elProxy.insertAfter(t.$el);
        } else {
          t.$elProxy = t.$el;
        }
        if (t.options.trigger == 'hover') {
          t.$elProxy
            .on(`mouseenter.${t.namespace}`, function () {
              if (!f() || t.options.touchDevices) {
                t.mouseIsOverProxy = true;
                t._show();
              }
            })
            .on(`mouseleave.${t.namespace}`, function () {
              if (!f() || t.options.touchDevices) {
                t.mouseIsOverProxy = false;
              }
            });
          if (u && t.options.touchDevices) {
            t.$elProxy.on(`touchstart.${t.namespace}`, function () {
              t._showNow();
            });
          }
        } else if (t.options.trigger == 'click') {
          t.$elProxy.on(`click.${t.namespace}`, function () {
            if (!f() || t.options.touchDevices) {
              t._show();
            }
          });
        }
      }
    },
    _interval_cancel() {
      clearInterval(this.checkInterval);
      this.checkInterval = null;
    },
    _interval_set() {
      const t = this;
      t.checkInterval = setInterval(function () {
        if (
          e('body').find(t.$el).length === 0 ||
          e('body').find(t.$elProxy).length === 0 ||
          t.Status == 'hidden' ||
          e('body').find(t.$tooltip).length === 0
        ) {
          if (t.Status == 'shown' || t.Status == 'appearing') t.hide();
          t._interval_cancel();
        } else if (t.options.positionTracker) {
          let n = t._repositionInfo(t.$elProxy);
          let r = false;
          if (o(n.dimension, t.elProxyPosition.dimension)) {
            if (t.$elProxy.css('position') === 'fixed') {
              if (o(n.position, t.elProxyPosition.position)) r = true;
            } else if (o(n.offset, t.elProxyPosition.offset)) r = true;
          }
          if (!r) {
            t.reposition();
            t.options.positionTrackerCallback.call(t, t.$el);
          }
        }
      }, 200);
    },
    _repositionInfo(e) {
      return {
        dimension: { height: e.outerHeight(false), width: e.outerWidth(false) },
        offset: e.offset(),
        position: {
          left: parseInt(e.css('left')),
          top: parseInt(e.css('top')),
        },
      };
    },
    _show() {
      const e = this;
      if (e.Status != 'shown' && e.Status != 'appearing') {
        if (e.options.delay) {
          e.timerShow = setTimeout(function () {
            if (
              e.options.trigger == 'click' ||
              (e.options.trigger == 'hover' && e.mouseIsOverProxy)
            ) {
              e._showNow();
            }
          }, e.options.delay);
        } else e._showNow();
      }
    },
    _showNow(n) {
      const r = this;
      r.options.functionBefore.call(r.$el, r.$el, function () {
        if (r.enabled && r.Content !== null) {
          if (n) r.callbacks.show.push(n);
          r.callbacks.hide = [];
          clearTimeout(r.timerShow);
          r.timerShow = null;
          clearTimeout(r.timerHide);
          r.timerHide = null;
          if (r.options.onlyOne) {
            e('.tooltipstered')
              .not(r.$el)
              .each(function (t, n) {
                const r = e(n);
                const i = r.data('tooltipster-ns');
                e.each(i, function (e, t) {
                  const n = r.data(t);
                  let i = n.status();
                  const s = n.option('autoClose');
                  if (i !== 'hidden' && i !== 'disappearing' && s) {
                    n.hide();
                  }
                });
              });
          }
          const i = function () {
            r.Status = 'shown';
            e.each(r.callbacks.show, function (e, t) {
              t.call(r.$el);
            });
            r.callbacks.show = [];
          };
          if (r.Status !== 'hidden') {
            var s = 0;
            if (r.Status === 'disappearing') {
              r.Status = 'appearing';
              if (l()) {
                r.$tooltip
                  .clearQueue()
                  .removeClass('tooltipster-dying')
                  .addClass(`tooltipster-${r.options.animation}-show`);
                if (r.options.speed > 0) r.$tooltip.delay(r.options.speed);
                r.$tooltip.queue(i);
              } else {
                r.$tooltip.stop().fadeIn(i);
              }
            } else if (r.Status === 'shown') {
              i();
            }
          } else {
            r.Status = 'appearing';
            var s = r.options.speed;
            r.bodyOverflowX = e('body').css('overflow-x');
            e('body').css('overflow-x', 'hidden');
            const o = `tooltipster-${r.options.animation}`;
              const a =
                `-webkit-transition-duration: ${ 
                r.options.speed 
                }ms; -webkit-animation-duration: ${ 
                r.options.speed 
                }ms; -moz-transition-duration: ${ 
                r.options.speed 
                }ms; -moz-animation-duration: ${ 
                r.options.speed 
                }ms; -o-transition-duration: ${ 
                r.options.speed 
                }ms; -o-animation-duration: ${ 
                r.options.speed 
                }ms; -ms-transition-duration: ${ 
                r.options.speed 
                }ms; -ms-animation-duration: ${ 
                r.options.speed 
                }ms; transition-duration: ${ 
                r.options.speed 
                }ms; animation-duration: ${ 
                r.options.speed 
                }ms;`;
              const f = r.options.minWidth
                ? `min-width:${  Math.round(r.options.minWidth)  }px;`
                : '';
              const c = r.options.maxWidth
                ? `max-width:${  Math.round(r.options.maxWidth)  }px;`
                : '';
              const h = r.options.interactive ? 'pointer-events: auto;' : '';
            r.$tooltip = e(
              `<div class="tooltipster-base ${r.options.theme}" style="${f} ${c} ${h} ${a}"><div class="tooltipster-content"></div></div>`,
            );
            if (l()) r.$tooltip.addClass(o);
            r._content_insert();
            r.$tooltip.appendTo('body');
            r.reposition();
            r.options.functionReady.call(r.$el, r.$el, r.$tooltip);
            if (l()) {
              r.$tooltip.addClass(`${o}-show`);
              if (r.options.speed > 0) r.$tooltip.delay(r.options.speed);
              r.$tooltip.queue(i);
            } else {
              r.$tooltip.css('display', 'none').fadeIn(r.options.speed, i);
            }
            r._interval_set();
            e(t).on(`scroll.${r.namespace} resize.${r.namespace}`, function () {
              r.reposition();
            });
            if (r.options.autoClose) {
              e('body').off(`.${r.namespace}`);
              if (r.options.trigger == 'hover') {
                if (u) {
                  setTimeout(function () {
                    e('body').on(`touchstart.${r.namespace}`, function () {
                      r.hide();
                    });
                  }, 0);
                }
                if (r.options.interactive) {
                  if (u) {
                    r.$tooltip.on(`touchstart.${r.namespace}`, function (e) {
                      e.stopPropagation();
                    });
                  }
                  let p = null;
                  r.$elProxy
                    .add(r.$tooltip)
                    .on(`mouseleave.${r.namespace}-autoClose`, function () {
                      clearTimeout(p);
                      p = setTimeout(function () {
                        r.hide();
                      }, r.options.interactiveTolerance);
                    })
                    .on(`mouseenter.${r.namespace}-autoClose`, function () {
                      clearTimeout(p);
                    });
                } else {
                  r.$elProxy.on(
                    `mouseleave.${r.namespace}-autoClose`,
                    function () {
                      r.hide();
                    },
                  );
                }
                if (r.options.hideOnClick) {
                  r.$elProxy.on(`click.${r.namespace}-autoClose`, function () {
                    r.hide();
                  });
                }
              } else if (r.options.trigger == 'click') {
                setTimeout(function () {
                  e('body').on(
                    `click.${r.namespace} touchstart.${r.namespace}`,
                    function () {
                      r.hide();
                    },
                  );
                }, 0);
                if (r.options.interactive) {
                  r.$tooltip.on(
                    `click.${r.namespace} touchstart.${r.namespace}`,
                    function (e) {
                      e.stopPropagation();
                    },
                  );
                }
              }
            }
          }
          if (r.options.timer > 0) {
            r.timerHide = setTimeout(function () {
              r.timerHide = null;
              r.hide();
            }, r.options.timer + s);
          }
        }
      });
    },
    _update(e) {
      const t = this;
      t._content_set(e);
      if (t.Content !== null) {
        if (t.Status !== 'hidden') {
          t._content_insert();
          t.reposition();
          if (t.options.updateAnimation) {
            if (l()) {
              t.$tooltip
                .css({
                  '-moz-transition': `all ${t.options.speed}ms, width 0ms, height 0ms, left 0ms, top 0ms`,
                  '-ms-transition': `all ${t.options.speed}ms, width 0ms, height 0ms, left 0ms, top 0ms`,
                  '-o-transition': `all ${t.options.speed}ms, width 0ms, height 0ms, left 0ms, top 0ms`,
                  '-webkit-transition': `all ${t.options.speed}ms, width 0ms, height 0ms, left 0ms, top 0ms`,
                  transition: `all ${t.options.speed}ms, width 0ms, height 0ms, left 0ms, top 0ms`,
                  width: '',
                })
                .addClass('tooltipster-content-changing');
              setTimeout(function () {
                if (t.Status != 'hidden') {
                  t.$tooltip.removeClass('tooltipster-content-changing');
                  setTimeout(function () {
                    if (t.Status !== 'hidden') {
                      t.$tooltip.css({
                        '-moz-transition': `${t.options.speed}ms`,
                        '-ms-transition': `${t.options.speed}ms`,
                        '-o-transition': `${t.options.speed}ms`,
                        '-webkit-transition': `${t.options.speed}ms`,
                        transition: `${t.options.speed}ms`,
                      });
                    }
                  }, t.options.speed);
                }
              }, t.options.speed);
            } else {
              t.$tooltip.fadeTo(t.options.speed, 0.5, function () {
                if (t.Status != 'hidden') {
                  t.$tooltip.fadeTo(t.options.speed, 1);
                }
              });
            }
          }
        }
      } else {
        t.hide();
      }
    },
    content(e) {
      if (typeof e === 'undefined') {
        return this.Content;
      }
      this._update(e);
      return this;
    },
    destroy() {
      const t = this;
      t.hide();
      if (t.$el[0] !== t.$elProxy[0]) {
        t.$elProxy.remove();
      }
      t.$el.removeData(t.namespace).off(`.${t.namespace}`);
      let n = t.$el.data('tooltipster-ns');
      if (n.length === 1) {
        let r = null;
        if (t.options.restoration === 'previous') {
          r = t.$el.data('tooltipster-initialTitle');
        } else if (t.options.restoration === 'current') {
          r =
            typeof t.Content === 'string'
              ? t.Content
              : e('<div></div>').append(t.Content).html();
        }
        if (r) {
          t.$el.attr('title', r);
        }
        t.$el
          .removeClass('tooltipstered')
          .removeData('tooltipster-ns')
          .removeData('tooltipster-initialTitle');
      } else {
        n = e.grep(n, function (e, n) {
          return e !== t.namespace;
        });
        t.$el.data('tooltipster-ns', n);
      }
      return t;
    },
    disable() {
      this.hide();
      this.enabled = false;
      return this;
    },
    elementIcon() {
      return this.$el[0] !== this.$elProxy[0] ? this.$elProxy[0] : undefined;
    },
    enable() {
      this.enabled = true;
      return this;
    },
    elementTooltip() {
      return this.$tooltip ? this.$tooltip[0] : undefined;
    },
    hide(n) {
      const r = this;
      if (n) r.callbacks.hide.push(n);
      r.callbacks.show = [];
      clearTimeout(r.timerShow);
      r.timerShow = null;
      clearTimeout(r.timerHide);
      r.timerHide = null;
      const i = function () {
        e.each(r.callbacks.hide, function (e, t) {
          t.call(r.$el);
        });
        r.callbacks.hide = [];
      };
      if (r.Status == 'shown' || r.Status == 'appearing') {
        r.Status = 'disappearing';
        const s = function () {
          r.Status = 'hidden';
          if (typeof r.Content === 'object' && r.Content !== null) {
            r.Content.detach();
          }
          r.$tooltip.remove();
          r.$tooltip = null;
          e(t).off(`.${  r.namespace}`);
          e('body')
            .off(`.${  r.namespace}`)
            .css('overflow-x', r.bodyOverflowX);
          e('body').off(`.${  r.namespace}`);
          r.$elProxy.off(`.${  r.namespace  }-autoClose`);
          r.options.functionAfter.call(r.$el, r.$el);
          i();
        };
        if (l()) {
          r.$tooltip
            .clearQueue()
            .removeClass(`tooltipster-${r.options.animation}-show`)
            .addClass('tooltipster-dying');
          if (r.options.speed > 0) r.$tooltip.delay(r.options.speed);
          r.$tooltip.queue(s);
        } else {
          r.$tooltip.stop().fadeOut(r.options.speed, s);
        }
      } else if (r.Status == 'hidden') {
        i();
      }
      return r;
    },
    option(e, t) {
      if (typeof t === 'undefined') return this.options[e];

      this.options[e] = t;
      return this;
    },
    show(e) {
      this._showNow(e);
      return this;
    },
    reposition() {
      let n = this;
      if (e('body').find(n.$tooltip).length !== 0) {
        n.$tooltip.css('width', '');
        n.elProxyPosition = n._repositionInfo(n.$elProxy);
        let r = null;
          var i = e(t).width();
          var s = n.elProxyPosition;
          var o = n.$tooltip.outerWidth(false);
          var u = n.$tooltip.innerWidth() + 1;
          var a = n.$tooltip.outerHeight(false);
        if (n.$elProxy.is('area')) {
          let f = n.$elProxy.attr('shape');
            var l = n.$elProxy.parent().attr('name');
            var c = e('img[usemap="#' + l + '"]');
            var h = c.offset().left;
            var p = c.offset().top;
            var d =
              n.$elProxy.attr('coords') !== undefined
                ? n.$elProxy.attr('coords').split(',')
                : undefined;
          if (f == 'circle') {
            var v = parseInt(d[0]);
              var m = parseInt(d[1]);
              var g = parseInt(d[2]);
            s.dimension.height = g * 2;
            s.dimension.width = g * 2;
            s.offset.top = p + m - g;
            s.offset.left = h + v - g;
          } else if (f == 'rect') {
            var v = parseInt(d[0]);
              var m = parseInt(d[1]);
              var y = parseInt(d[2]);
              var b = parseInt(d[3]);
            s.dimension.height = b - m;
            s.dimension.width = y - v;
            s.offset.top = p + m;
            s.offset.left = h + v;
          } else if (f == 'poly') {
            let w = [];
              var E = [];
              var S = 0;
              var x = 0;
              var T = 0;
              var N = 0;
              var C = 'even';
            for (let k = 0; k < d.length; k++) {
              let L = parseInt(d[k]);
              if (C == 'even') {
                if (L > T) {
                  T = L;
                  if (k === 0) {
                    S = T;
                  }
                }
                if (L < S) {
                  S = L;
                }
                C = 'odd';
              } else {
                if (L > N) {
                  N = L;
                  if (k == 1) {
                    x = N;
                  }
                }
                if (L < x) {
                  x = L;
                }
                C = 'even';
              }
            }
            s.dimension.height = N - x;
            s.dimension.width = T - S;
            s.offset.top = p + x;
            s.offset.left = h + S;
          } else {
            s.dimension.height = c.outerHeight(false);
            s.dimension.width = c.outerWidth(false);
            s.offset.top = p;
            s.offset.left = h;
          }
        }
        let A = 0;
          var O = 0;
          var M = 0;
          var _ = parseInt(n.options.offsetY);
          var D = parseInt(n.options.offsetX);
          var P = n.options.position;
        function H() {
          let n = e(t).scrollLeft();
          if (A - n < 0) {
            r = A - n;
            A = n;
          }
          if (A + o - n > i) {
            r = A - (i + n - o);
            A = i + n - o;
          }
        }
        function B(n, r) {
          if (
            s.offset.top - e(t).scrollTop() - a - _ - 12 < 0 &&
            r.indexOf('top') > -1
          ) {
            P = n;
          }
          if (
            s.offset.top + s.dimension.height + a + 12 + _ >
              e(t).scrollTop() + e(t).height() &&
            r.indexOf('bottom') > -1
          ) {
            P = n;
            M = s.offset.top - a - _ - 12;
          }
        }
        if (P == 'top') {
          var j = s.offset.left + o - (s.offset.left + s.dimension.width);
          A = s.offset.left + D - j / 2;
          M = s.offset.top - a - _ - 12;
          H();
          B('bottom', 'top');
        }
        if (P == 'top-left') {
          A = s.offset.left + D;
          M = s.offset.top - a - _ - 12;
          H();
          B('bottom-left', 'top-left');
        }
        if (P == 'top-right') {
          A = s.offset.left + s.dimension.width + D - o;
          M = s.offset.top - a - _ - 12;
          H();
          B('bottom-right', 'top-right');
        }
        if (P == 'bottom') {
          var j = s.offset.left + o - (s.offset.left + s.dimension.width);
          A = s.offset.left - j / 2 + D;
          M = s.offset.top + s.dimension.height + _ + 12;
          H();
          B('top', 'bottom');
        }
        if (P == 'bottom-left') {
          A = s.offset.left + D;
          M = s.offset.top + s.dimension.height + _ + 12;
          H();
          B('top-left', 'bottom-left');
        }
        if (P == 'bottom-right') {
          A = s.offset.left + s.dimension.width + D - o;
          M = s.offset.top + s.dimension.height + _ + 12;
          H();
          B('top-right', 'bottom-right');
        }
        if (P == 'left') {
          A = s.offset.left - D - o - 12;
          O = s.offset.left + D + s.dimension.width + 12;
          var F = s.offset.top + a - (s.offset.top + s.dimension.height);
          M = s.offset.top - F / 2 - _;
          if (A < 0 && O + o > i) {
            var I = parseFloat(n.$tooltip.css('border-width')) * 2;
              var q = o + A - I;
            n.$tooltip.css('width', `${q  }px`);
            a = n.$tooltip.outerHeight(false);
            A = s.offset.left - D - q - 12 - I;
            F = s.offset.top + a - (s.offset.top + s.dimension.height);
            M = s.offset.top - F / 2 - _;
          } else if (A < 0) {
            A = s.offset.left + D + s.dimension.width + 12;
            r = 'left';
          }
        }
        if (P == 'right') {
          A = s.offset.left + D + s.dimension.width + 12;
          O = s.offset.left - D - o - 12;
          var F = s.offset.top + a - (s.offset.top + s.dimension.height);
          M = s.offset.top - F / 2 - _;
          if (A + o > i && O < 0) {
            var I = parseFloat(n.$tooltip.css('border-width')) * 2;
              var q = i - A - I;
            n.$tooltip.css('width', `${q  }px`);
            a = n.$tooltip.outerHeight(false);
            F = s.offset.top + a - (s.offset.top + s.dimension.height);
            M = s.offset.top - F / 2 - _;
          } else if (A + o > i) {
            A = s.offset.left - D - o - 12;
            r = 'right';
          }
        }
        if (n.options.arrow) {
          let R = `tooltipster-arrow-${  P}`;
          if (n.options.arrowColor.length < 1) {
            var U = n.$tooltip.css('background-color');
          } else {
            var U = n.options.arrowColor;
          }
          if (!r) {
            r = '';
          } else if (r == 'left') {
            R = 'tooltipster-arrow-right';
            r = '';
          } else if (r == 'right') {
            R = 'tooltipster-arrow-left';
            r = '';
          } else {
            r = `left:${  Math.round(r)  }px;`;
          }
          if (P == 'top' || P == 'top-left' || P == 'top-right') {
            var z = parseFloat(n.$tooltip.css('border-bottom-width'));
              var W = n.$tooltip.css('border-bottom-color');
          } else if (
            P == 'bottom' ||
            P == 'bottom-left' ||
            P == 'bottom-right'
          ) {
            var z = parseFloat(n.$tooltip.css('border-top-width'));
              var W = n.$tooltip.css('border-top-color');
          } else if (P == 'left') {
            var z = parseFloat(n.$tooltip.css('border-right-width'));
              var W = n.$tooltip.css('border-right-color');
          } else if (P == 'right') {
            var z = parseFloat(n.$tooltip.css('border-left-width'));
              var W = n.$tooltip.css('border-left-color');
          } else {
            var z = parseFloat(n.$tooltip.css('border-bottom-width'));
              var W = n.$tooltip.css('border-bottom-color');
          }
          if (z > 1) {
            z++;
          }
          let X = '';
          if (z !== 0) {
            let V = '';
              var J = `border-color: ${  W  };`;
            if (R.indexOf('bottom') !== -1) {
              V = `margin-top: -${  Math.round(z)  }px;`;
            } else if (R.indexOf('top') !== -1) {
              V = `margin-bottom: -${  Math.round(z)  }px;`;
            } else if (R.indexOf('left') !== -1) {
              V = `margin-right: -${  Math.round(z)  }px;`;
            } else if (R.indexOf('right') !== -1) {
              V = `margin-left: -${  Math.round(z)  }px;`;
            }
            X =
              `<span class="tooltipster-arrow-border" style="${ 
              V 
              } ${ 
              J 
              };"></span>`;
          }
          n.$tooltip.find('.tooltipster-arrow').remove();
          let K =
            `<div class="${ 
            R 
            } tooltipster-arrow" style="${ 
            r 
            }">${ 
            X 
            }<span style="border-color:${ 
            U 
            };"></span></div>`;
          n.$tooltip.append(K);
        }
        n.$tooltip.css({
          left: Math.round(A) + 'px',
          top: Math.round(M) + 'px',
        });
      }
      return n;
    },
    update (e) {
      return this.content(e);
    },
    status() {
      return this.Status;
    },
  };
  e.fn[r] = function () {
    const t = arguments;
    if (this.length === 0) {
      if (typeof t[0] === 'string') {
        let n = true;
        switch (t[0]) {
          case 'setDefaults':
            e.extend(i, t[1]);
            break;
          default:
            n = false;
            break;
        }
        if (n) return true;
        return this;
      }
      return this;
    }
    if (typeof t[0] === 'string') {
      let r = '#*$~&';
      this.each(function () {
        const n = e(this).data('tooltipster-ns');
        const i = n ? e(this).data(n[0]) : null;
        if (i) {
          if (typeof i[t[0]] === 'function') {
            var s = i[t[0]](t[1], t[2]);
          } else {
            throw new Error(`Unknown method .tooltipster("${t[0]}")`);
          }
          if (s !== i) {
            r = s;
            return false;
          }
        } else {
          throw new Error(
            `You called Tooltipster's "${t[0]}" method on an uninitialized element`,
          );
        }
      });
      return r !== '#*$~&' ? r : this;
    }
    const o = [];
    const u = t[0] && typeof t[0].multiple !== 'undefined';
    const a = (u && t[0].multiple) || (!u && i.multiple);
    const f = t[0] && typeof t[0].debug !== 'undefined';
    const l = (f && t[0].debug) || (!f && i.debug);
    this.each(function () {
      let n = false;
      let r = e(this).data('tooltipster-ns');
      let i = null;
      if (!r) {
        n = true;
      } else if (a) {
        n = true;
      } else if (l) {
        console.log(
          'Tooltipster: one or more tooltips are already attached to this element: ignoring. Use the "multiple" option to attach more tooltips.',
        );
      }
      if (n) {
        i = new s(this, t[0]);
        if (!r) r = [];
        r.push(i.namespace);
        e(this).data('tooltipster-ns', r);
        e(this).data(i.namespace, i);
      }
      o.push(i);
    });
    if (a) return o;
    return this;
  };
  var u = !!('ontouchstart' in t);
  var a = false;
  e('body').one('mousemove', () => {
    a = true;
  });
})(jQuery, window, document);
